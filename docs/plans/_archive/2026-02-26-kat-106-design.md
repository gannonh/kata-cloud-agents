# KAT-106 Design: PostgreSQL Schema + Drizzle Migrations

Date: 2026-02-26  
Issue: KAT-106  
Status: Approved design

## Goal

Establish the initial relational data model in `packages/db` using Drizzle ORM and migration-first workflows, including local Docker Compose infrastructure for PostgreSQL and Redis.

## Scope

Included tables:
- `users`
- `teams`
- `team_members`
- `specs`
- `spec_versions`
- `agent_runs`
- `tasks`
- `artifacts`
- `audit_log`
- `api_keys` (added during design review for parity with shared domain types)

Out of scope:
- API route implementation
- Auth flow/business logic
- Runtime orchestration features beyond schema and infra scaffolding

## Architecture and Ownership

- `packages/shared` remains the domain type contract.
- `packages/db` owns persistence modeling, Drizzle schema declarations, and SQL migration history.
- Schema and migration files in `packages/db` are the source of truth for database structure.
- Migrations are committed and treated as immutable history.

## Data Model

### Primary Keys

- UUID primary keys for entity tables: `users`, `teams`, `specs`, `spec_versions`, `agent_runs`, `tasks`, `artifacts`, `audit_log`, `api_keys`.
- Composite primary key for `team_members`: (`user_id`, `team_id`).

### Relationships

- `team_members.user_id -> users.id`
- `team_members.team_id -> teams.id`
- `specs.team_id -> teams.id`
- `specs.created_by -> users.id`
- `spec_versions.spec_id -> specs.id`
- `agent_runs.spec_id -> specs.id`
- `tasks.spec_id -> specs.id`
- `tasks.agent_run_id -> agent_runs.id` (nullable)
- `artifacts.agent_run_id -> agent_runs.id`
- `audit_log.team_id -> teams.id`
- `audit_log.agent_run_id -> agent_runs.id` (nullable)
- `api_keys.team_id -> teams.id`
- `api_keys.created_by -> users.id`

### Uniqueness and Integrity

- Unique `users.email`
- Unique `teams.slug`
- Unique `api_keys.key_hash`
- Unique (`spec_id`, `version_number`) on `spec_versions`
- Strong foreign key constraints across all relationship columns

### Enums and Structured Fields

- DB enum-backed status/role fields where stable:
  - `team_members.role`
  - `specs.status`
  - `agent_runs.status`
  - `tasks.status`
- JSONB fields for flexible payloads:
  - `specs.content`
  - `spec_versions.content`
  - `artifacts.metadata`
  - `audit_log.details`
  - `tasks.result`
- `tasks.depends_on` stored as `uuid[]`.

### API Keys Decision

`api_keys` includes:
- `expires_at` nullable
- `revoked_at` nullable
- `last_used_at` nullable

Active status is derived from timestamps (not stored as a separate boolean).

### Timestamp Conventions

Use snake_case timestamp columns (`created_at`, `updated_at`, `started_at`, `completed_at`, etc.) with DB defaults where appropriate.

## Migration and Infra Flow

- Define Drizzle schema in `packages/db/src/schema/*`.
- Generate SQL migrations from schema changes.
- Apply migrations against local PostgreSQL.
- Commit generated migration files to version control.
- Add Docker Compose for local `postgres` + `redis` with health checks and persistent volumes.
- Provide environment variable template(s) for connection strings.

## Error Handling

- Migration command failures are fail-fast and non-zero exit.
- FK and unique violations are intentionally surfaced by the DB layer.
- Enum violations fail at write-time to protect data integrity.

## Testing Strategy

- Schema tests assert key columns, nullability, and constraints exist.
- Migration smoke test:
  - boot compose services
  - run migrations
  - verify schema reaches expected state
- Keep tests deterministic and CI-friendly.

## Approach Chosen

Selected approach: strong relational schema with explicit constraints and Drizzle migrations.

Alternatives considered:
- Minimal constraints for speed (rejected: weaker integrity, likely near-term migration churn)
- JSON-heavy flexible schema (rejected: pushes validation burden into application code)

## Success Criteria

- `packages/db` defines all required tables plus `api_keys`
- Relational constraints and indexes are present for core integrity/performance
- Migrations apply cleanly to local PostgreSQL via Docker Compose
- Schema aligns with existing shared domain contracts without introducing contradictory states
