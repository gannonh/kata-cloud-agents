# KAT-108 Design: API Server Skeleton (Hono) with Auth Middleware

Date: 2026-02-26  
Issue: KAT-108  
Status: Approved design

## Goal

Create `packages/gateway` as a production-oriented API skeleton using Hono with health checks, auth middleware, CORS, logging, error normalization, route groups, OpenAPI generation, and basic rate limiting.

## Source of Truth

- Linear issue: `KAT-108` (API server skeleton with auth middleware).
- Wave dependency diagram provided in this thread indicates KAT-108 runs in Wave 3 parallel to KAT-106.

## Parallelism Constraint (No Conflict with KAT-106)

KAT-108 must be executable independently of KAT-106 database work.

Boundaries:
- No direct imports from `@kata/db`.
- No SQL schema dependence in `packages/gateway`.
- Persistence responsibilities abstracted behind interfaces in gateway.
- Session auth uses Redis (mandatory) and fails closed when unavailable.

## Architecture

- `createGatewayApp(config, deps)` factory returns a Hono app for testability.
- Network runtime entrypoint wraps app factory and starts Node server.
- Middleware pipeline is centralized and ordered.
- Route groups are registered with consistent middleware and typed response contracts.
- OpenAPI spec generated from route definitions using Zod integration.

## Request Pipeline

1. Request context/bootstrap middleware (`requestId`, timing metadata).
2. Structured request logging middleware.
3. CORS middleware (allowlist + credentials for session flows).
4. Global error middleware (uniform JSON envelope).
5. Rate limit middleware (basic protection per key).
6. Auth middleware for protected routes:
   - API key validation via adapter interface.
   - Session validation via signed cookie + Redis session lookup.
   - Fail closed if Redis is unavailable or lookup fails.
7. Route handlers.

## Components and Interfaces

### Config

Validated gateway config containing:
- `PORT`
- `ALLOWED_ORIGINS`
- session signing secret(s)
- `REDIS_URL`
- rate-limit settings

### Auth Adapters

`ApiKeyAuthAdapter`
- `validateApiKey(rawKey): Promise<{ teamId: string; keyId: string; scopes?: string[] } | null>`

`SessionStoreAdapter`
- `getSession(sessionId): Promise<{ userId: string; teamId: string; expiresAt: string } | null>`

### Auth Context

Middleware attaches principal context to requests:
- `type: 'api_key' | 'session_user'`
- actor identifiers (`teamId`, `userId` or `keyId`)

### Routes

- `GET /health` (public)
- Route groups (protected skeleton endpoints):
  - `/api/specs`
  - `/api/agents`
  - `/api/teams`
  - `/api/artifacts`

Each group includes at least one placeholder endpoint with typed responses.

## Error Handling

Uniform response envelope:

```json
{
  "error": {
    "code": "string",
    "message": "string",
    "requestId": "string"
  }
}
```

Status mapping:
- `400` validation failures
- `401/403` authentication/authorization failures
- `429` rate-limit exceeded
- `500` unhandled internal errors

## Security Decisions

- Redis-backed session validation is mandatory for protected routes.
- Protected routes fail closed if Redis errors or cannot be reached.
- Raw API keys are never logged.
- Unknown origins denied by default CORS policy.
- Rate limiting occurs before expensive handlers.

## Testing Strategy

Unit tests:
- auth middleware: API key success/failure
- auth middleware: session success/failure
- session fail-closed behavior on Redis unavailability
- error middleware mapping + response envelope
- rate limiter keying and threshold behavior

Integration tests (app factory level):
- `GET /health` returns success
- protected endpoints reject missing credentials
- protected endpoints accept valid mocked credentials
- OpenAPI endpoint contains expected groups/tags/schemas

## Non-Goals

- Full CRUD implementation for specs/agents/teams/artifacts
- DB-backed repository implementation in gateway
- Distributed, production-grade rate limiting across multiple nodes
- Advanced authorization policy beyond middleware skeleton

## Success Criteria

- `packages/gateway` has a runnable Hono skeleton with middleware stack and route groups.
- OpenAPI generation is wired and test-verified.
- Redis-backed session authentication is enforced with fail-closed behavior.
- Implementation remains independent from `@kata/db` so KAT-106 can proceed in parallel.
