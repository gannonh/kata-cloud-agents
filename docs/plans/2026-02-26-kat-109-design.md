# KAT-109 Design: WebSocket Server for Real-Time Updates

Date: 2026-02-26  
Issue: KAT-109  
Status: Approved design

## Goal

Add native WebSocket support to `packages/gateway` for authenticated, channel-based real-time updates, and provide a shared reconnecting client package used by web, desktop, and mobile apps.

## Source of Truth

- Linear issue: `KAT-109` (WebSocket server for real-time updates)
- Project docs:
  - `docs/PROJECT_PLAN.md`
  - `docs/M0-dependency-graph.mermaid`
- Current gateway architecture from KAT-108 (`createGatewayApp`, auth middleware, route grouping, fail-closed behavior)

## Clarified Scope Decisions

1. Auth on connect supports both API key and session cookie.
2. This ticket includes server implementation and client reconnection helper implementation.
3. Reusable client lives in new package: `packages/realtime-client` (`@kata/realtime-client`).
4. Initial transport uses JSON text frames; protocol includes explicit envelope fields to add binary frames later without breaking compatibility.

## Approaches Considered

### 1) In-process WS server in gateway + in-memory channel hub + shared client (chosen)

Pros:
- Fastest path for M0 dependency chain.
- Reuses existing gateway auth and observability patterns.
- Minimal infra changes.

Cons:
- Cross-instance fanout needs Redis pub/sub later when horizontally scaling.

### 2) Dedicated realtime service now

Pros:
- Clean service separation and easier long-term independent scaling.

Cons:
- Too much operational and integration overhead for this milestone.

### 3) Protocol-only skeleton now

Pros:
- Lowest short-term implementation risk.

Cons:
- Does not deliver working real-time behavior required by the issue.

## Architecture

### Server-side modules (`packages/gateway/src/realtime`)

- `server.ts`: upgrade handling, connection lifecycle, registry.
- `protocol.ts`: runtime message validation and typed envelopes.
- `channels.ts`: subscription registry and channel authorization gates.
- `heartbeat.ts`: ping/pong scheduling and stale connection cleanup.
- `publisher.ts`: internal event publish API (`publish(channel, message)`) for gateway producers.

### Client package (`packages/realtime-client`)

- Reusable browser-compatible WebSocket client.
- Reconnection with exponential backoff + jitter and automatic resubscribe.
- Lifecycle events: `connecting`, `connected`, `reconnecting`, `disconnected`, `error`.

### App integration

- `apps/web`, `apps/desktop`, `apps/mobile` consume `@kata/realtime-client`.
- Initial integration target: instantiate client and subscribe to a test/dev channel path to validate wiring.

## Protocol Design

### Envelope (server -> client)

```json
{
  "type": "agent_status_changed",
  "channel": "agent:123",
  "timestamp": "2026-02-26T22:00:00.000Z",
  "eventId": "evt_abc123",
  "encoding": "json",
  "payload": {}
}
```

Fields:
- `type`: `agent_status_changed | log_entry | spec_updated | task_completed | blocker_raised | subscribed | unsubscribed | error | pong`
- `channel`: optional channel for event routing context
- `timestamp`: ISO-8601 event timestamp
- `eventId`: stable id for client dedupe/ordering
- `encoding`: `json` for this ticket (binary-compatible extension point)
- `payload`: typed event body

### Client -> server commands

- `subscribe` with `channel`
- `unsubscribe` with `channel`
- `ping`

### Channel model

- `spec:{id}`
- `agent:{id}`
- `team:{id}`

Authorization rules:
- `team:{id}` must match authenticated principal `teamId`.
- `spec:{id}` and `agent:{id}` must resolve to the authenticated principal's team via adapter checks.
- Authorization lookup failures fail closed.

## Data Flow

1. Client connects via WebSocket with API key header or session cookie context.
2. Gateway authenticates during connection bootstrap (same security model as KAT-108).
3. Client subscribes/unsubscribes to channels.
4. Gateway validates channel format and authorization, then mutates subscription state.
5. Internal publishers push domain events into channel hub.
6. Hub fans out events to subscribed connections.
7. Heartbeat monitors liveness with ping/pong and closes stale sockets.
8. Client reconnects and restores prior subscriptions.

## Error Handling and Reliability

- Invalid auth: reject connection with explicit close reason/code.
- Invalid command/channel: send `error` event and keep connection alive.
- Authorization backend error: fail closed for that request and log context.
- Unhealthy backpressure client: close connection and rely on reconnect.
- Heartbeat timeout: close and allow reconnect workflow.
- Reconnect uses bounded exponential backoff with jitter.

## Testing Strategy

### Gateway tests

- Auth on connect: API key success/failure, session success/failure, adapter error fail-closed.
- Subscription authorization for each channel family.
- Fanout correctness across multiple subscribers/channels.
- Heartbeat timeout and disconnect cleanup.
- Invalid frame/command handling.

### Realtime client tests

- Reconnect backoff policy.
- Automatic resubscribe after reconnect.
- Connection lifecycle callbacks/events.

### App smoke tests

- Web/desktop/mobile can instantiate client and subscribe without runtime errors.

## Non-Goals

- Redis pub/sub cross-instance broadcasting.
- Delivery replay history / guaranteed ordering beyond per-connection stream order.
- Full binary frame transport for log streaming in this ticket.

## Acceptance Mapping

- Native WebSocket: implemented in gateway with no Socket.io.
- Channel subscriptions: `spec:{id}`, `agent:{id}`, `team:{id}`.
- Auth on connect: API key + session cookie paths supported.
- Heartbeat: ping/pong liveness checks with stale cleanup.
- Reconnection handling: shared client package with backoff + resubscribe.
- Message types: all required event type envelopes supported.
- Binary support: protocol-compatible envelope and `encoding` field reserved; JSON transport in current scope.
